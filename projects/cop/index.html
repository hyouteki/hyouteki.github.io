<!doctype html><html lang=en><head><meta charset=utf-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1" name=viewport><meta content=#5100ff name=theme-color><link href=https://hyouteki.github.io/projects/cop/ rel=canonical><title>
     exploring COmpiler OPtimizations - Ninthcircle
    
  </title><link href=https://hyouteki.github.io/style.css rel=stylesheet><link href=/apple-touch-icon.png rel=apple-touch-icon sizes=180x180><link href=/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link href=/site.webmanifest rel=manifest><link href=https://vmst.io/@hyouteki rel=me><meta content=Ninthcircle property=og:site_name><meta content="
     exploring COmpiler OPtimizations - Ninthcircle
    " property=og:title><meta content=https://hyouteki.github.io/projects/cop/ property=og:url><meta content="Repository for exploring compiler optimizations. Includes writing a null pointer de-reference detection compiler pass, garbage collector SafeGC for C lang and Spatial & weaker type safety for the C lang via disallowing out-of-bound pointer accesses and storage of invalid addresses." property=og:description><meta content=https://hyouteki.github.io/card.png property=og:image><meta content=summary_large_image property=twitter:card><body><header><nav><a href=https://hyouteki.github.io> <i class="bi bi-house"></i> Ninthcircle </a><ul><li><a href=https://hyouteki.github.io/blogs target=_blank> <i class="bi bi-journal-bookmark"></i> Blogs </a><li><a href=https://hyouteki.github.io/toys target=_blank> <i class="bi bi-joystick"></i> Toys </a><li><a href=https://hyouteki.github.io/projects target=_blank> <i class="bi bi-pc-display"></i> Projects </a><li><a href=https://hyouteki.github.io/writings target=_blank> <i class="bi bi-vector-pen"></i> Writings </a><li><a href=https://github.com/hyouteki target=_blank> <i class="bi bi-github"></i> </a><li><a href=https://www.linkedin.com/in/hyouteki/ target=_blank> <i class="bi bi-linkedin"></i> </a><li><a href=https://twitter.com/mainlakshayhoon target=_blank> <i class="bi bi-twitter-x"></i> </a></ul></nav></header><div class=container><h1>exploring COmpiler OPtimizations</h1><small> <time datetime=2024-02-21T00:00:00+00:00 pubdate>21 February 2024</time> <span>•</span> <ul class=tags><li><a class=tag href=https://hyouteki.github.io/tags/c/>c</a><li><a class=tag href=https://hyouteki.github.io/tags/cpp/>cpp</a><li><a class=tag href=https://hyouteki.github.io/tags/llvm/>llvm</a><li><a class=tag href=https://hyouteki.github.io/tags/safe-gc/>safe-gc</a><li><a class=tag href=https://hyouteki.github.io/tags/compiler-pass/>compiler-pass</a><li><a class=tag href=https://hyouteki.github.io/tags/type-safety/>type-safety</a><li><a class=tag href=https://hyouteki.github.io/tags/probe/>probe</a><li><a class=tag href=https://hyouteki.github.io/tags/systems/>systems</a></ul> </small><h2>Table of Contents</h2><ul><li><a href=https://hyouteki.github.io/projects/cop/#null-pointer-dereference-detection-compiler-pass>Null pointer dereference detection compiler pass</a> <ul><li><a href=https://hyouteki.github.io/projects/cop/#building-the-pass-from-scratch>Building the pass from scratch</a><li><a href=https://hyouteki.github.io/projects/cop/#how-does-this-work>How does this work</a><li><a href=https://hyouteki.github.io/projects/cop/#forward-data-flow-analysis>Forward data flow analysis</a><li><a href=https://hyouteki.github.io/projects/cop/#transfer-function>Transfer function</a><li><a href=https://hyouteki.github.io/projects/cop/#meet-operator>Meet operator</a><li><a href=https://hyouteki.github.io/projects/cop/#initialization>Initialization</a><li><a href=https://hyouteki.github.io/projects/cop/#assumptions>Assumptions</a><li><a href=https://hyouteki.github.io/projects/cop/#miscellaneous>Miscellaneous</a></ul><li><a href=https://hyouteki.github.io/projects/cop/#conservative-garbage-collecter-safe-gc-for-clang>Conservative garbage collecter (Safe GC) for Clang</a> <ul><li><a href=https://hyouteki.github.io/projects/cop/#building-the-project>Building the project</a><li><a href=https://hyouteki.github.io/projects/cop/#how-does-this-work-1>How does this work</a><li><a href=https://hyouteki.github.io/projects/cop/#tests>Tests</a></ul><li><a href=https://hyouteki.github.io/projects/cop/#spatial-and-weaker-type-safety-for-the-c-lang>Spatial and weaker type safety for the C lang</a> <ul><li><a href=https://hyouteki.github.io/projects/cop/#building-the-pass-from-scratch-1>Building the pass from scratch</a><li><a href=https://hyouteki.github.io/projects/cop/#how-does-this-work-2>How does this work</a><li><a href=https://hyouteki.github.io/projects/cop/#miscellaneous-1>Miscellaneous</a></ul></ul><h1 id=null-pointer-dereference-detection-compiler-pass>Null pointer dereference detection compiler pass</h1><h2 id=building-the-pass-from-scratch>Building the pass from scratch</h2><pre class="language-bash z-code" data-lang=bash><code class=language-bash data-lang=bash><span class="z-source z-shell z-bash"><span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">git</span></span><span class="z-meta z-function-call z-arguments z-shell"> clone https://github.com/Systems-IIITD/CSE601</span>
<span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">git</span></span><span class="z-meta z-function-call z-arguments z-shell"> clone https://github.com/hyouteki/cop</span>
<span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">mv</span></span><span class="z-meta z-function-call z-arguments z-shell"> cop/nullchecks/NullChecks.cpp CSE601/llvm/lib/CodeGen/SafeC/</span>
<span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">sudo</span></span><span class="z-meta z-function-call z-arguments z-shell"> apt install cmake ninja-build</span>
</span></code></pre><pre class="language-bash z-code" data-lang=bash><code class=language-bash data-lang=bash><span class="z-source z-shell z-bash"><span class="z-meta z-function-call z-shell"><span class="z-support z-function z-cd z-shell">cd</span></span><span class="z-meta z-function-call z-arguments z-shell"> CSE601</span>
<span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">mkdir</span></span><span class="z-meta z-function-call z-arguments z-shell"> build</span>
<span class="z-meta z-function-call z-shell"><span class="z-support z-function z-cd z-shell">cd</span></span><span class="z-meta z-function-call z-arguments z-shell"> build</span> <span class="z-keyword z-operator z-logical z-and z-shell">&&</span> <span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">cp</span></span><span class="z-meta z-function-call z-arguments z-shell"> ../scripts/build.sh .</span> <span class="z-keyword z-operator z-logical z-and z-shell">&&</span> <span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">sh</span></span><span class="z-meta z-function-call z-arguments z-shell"> build.sh</span> <span class="z-keyword z-operator z-logical z-and z-shell">&&</span> <span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">ninja</span></span><span class="z-meta z-function-call z-arguments z-shell"><span class="z-variable z-parameter z-option z-shell"><span class="z-punctuation z-definition z-parameter z-shell"> -</span>j</span> 4</span>
<span class="z-meta z-function-call z-shell"><span class="z-support z-function z-cd z-shell">cd</span></span><span class="z-meta z-function-call z-arguments z-shell"> tests</span> <span class="z-keyword z-operator z-logical z-and z-shell">&&</span> <span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">make</span></span>
</span></code></pre><blockquote><p><strong>Note</strong>: If you encounter error such as<pre class="language-bash z-code" data-lang=bash><code class=language-bash data-lang=bash><span class="z-source z-shell z-bash"><span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">/home/puneetku/CSE601/llvm/utils/benchmark/src/benchmark_register.h:17:30:</span></span><span class="z-meta z-function-call z-arguments z-shell"> error: ‘numeric_limits’ is not a member of ‘std’</span>
<span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">17</span></span> <span class="z-keyword z-operator z-logical z-pipe z-shell">|</span>   <span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">static</span></span><span class="z-meta z-function-call z-arguments z-shell"> const T kmax = std::numeric_limits<span class="z-keyword z-operator z-assignment z-redirection z-shell"><</span>T<span class="z-keyword z-operator z-assignment z-redirection z-shell">></span>::max(</span><span class="z-meta z-function-call z-shell"></span>)<span class="z-keyword z-operator z-logical z-continue z-shell">;</span>
</span></code></pre><p>Try adding <code>#include&LTlimits></code> in the header file and re-building the project</blockquote><blockquote><p><strong>Note</strong>: For subsequent builds just run <code>cd build && ninja -j 4</code> inside <code>CSE601</code> directory</blockquote><blockquote><p><strong>Note</strong>: For testing the pass run the following command <code>cd tests/PA1/ && make clean && make -B</code> inside <code>CSE601</code> directory</blockquote><h2 id=how-does-this-work>How does this work</h2><p>There are mainly 4 instructions that may lead to segmentation faults while dereferencing null pointers.<ol><li>Store<li>Load<li>GetElementPtr<li>Call (Indirect)</ol><blockquote><p><strong>Naïve solution:</strong> Adding nullchecks before every instructions of these four types. But it will lead to multiple compare and conditional branch instructions.</blockquote><p>Better solution for this is to use forward data flow analysis to track every pointer and add nullchecks only when we are unsure of it being null safe. <em>(Similar to constant propagation data flow analysis)</em><h3 id=for-this-we-have-2-maps>For this we have 2 maps:</h3><pre class="language-c++ z-code" data-lang=c++><code class=language-c++ data-lang=c++><span class="z-source z-c++">std<span class="z-punctuation z-accessor z-double-colon z-c++">::</span>unordered_map<span class="z-punctuation z-section z-generic z-begin z-c++"><</span>Value <span class="z-keyword z-operator z-c">*</span><span class="z-punctuation z-separator z-c++">,</span> std<span class="z-punctuation z-accessor z-double-colon z-c++">::</span>unordered_set<span class="z-punctuation z-section z-generic z-begin z-c++"><</span>Value <span class="z-keyword z-operator z-c">*</span><span class="z-punctuation z-section z-generic z-end z-c++">></span><span class="z-punctuation z-section z-generic z-end z-c++">></span> childPointers<span class="z-punctuation z-terminator z-c++">;</span>
std<span class="z-punctuation z-accessor z-double-colon z-c++">::</span>unordered_map<span class="z-punctuation z-section z-generic z-begin z-c++"><</span>Value <span class="z-keyword z-operator z-c">*</span><span class="z-punctuation z-separator z-c++">,</span> <span class="z-storage z-type z-c">bool</span><span class="z-punctuation z-section z-generic z-end z-c++">></span> unsafePointers<span class="z-punctuation z-terminator z-c++">;</span>
</span></code></pre><ul><li><p><code>childPointers</code> maps each pointer to a set of its child pointers. Or in other words every child pointer’s value is dependent upon its parent pointer.</p> <pre class="language-cpp z-code" data-lang=cpp><code class=language-cpp data-lang=cpp><span class="z-source z-c++"><span class="z-keyword z-operator z-arithmetic z-c">%</span>a <span class="z-keyword z-operator z-assignment z-c">=</span> load i32<span class="z-keyword z-operator z-c">*</span><span class="z-punctuation z-separator z-c++">,</span> i32<span class="z-keyword z-operator z-c">*</span><span class="z-keyword z-operator z-c">*</span> <span class="z-keyword z-operator z-arithmetic z-c">%</span>a<span class="z-punctuation z-accessor z-dot z-c++">.</span><span class="z-variable z-other z-readwrite z-member z-c++">addr</span><span class="z-punctuation z-terminator z-c++">;</span>
</span></code></pre> <blockquote><p>In this example <code>%a</code> is the child pointer of <code>%a.addr</code>. As if the value of <code>%a.addr</code> changes the value present in <code>%a</code> is corrupted and new value may not be null safe.</blockquote><li><p><code>unsafePointers</code> just tells whether a pointer present in the map is unsafe or not.</p></ul><blockquote><p>The <code>childPointers</code> map is preserved through out the function, but the <code>unsafePointers</code> map resets at each basic block. As from any basic block, one can reach any basic block. Thus any basic block could have modified the pointer thus making them unsafe, so we can’t rely on previous observations.</blockquote><h2 id=forward-data-flow-analysis>Forward data flow analysis</h2><ul><li>There are two APIs first is <code>includeInst</code> and <code>processInst</code>.<li><code>includeInst</code> takes in the instruction and both maps. And outputs whether we should add nullchecks for this instruction.<li><code>processInst</code> adds nullchecks for the given instruction.<li>The transfer functions are present in the <code>includeInst</code>.</ul><h2 id=transfer-function>Transfer function</h2><blockquote><p>Function definition an be found <a href=https://github.com/hyouteki/cop/blob/b808590a4f501e6febeacfb7e6014e468da4f78b/nullchecks/NullChecks.cpp#L81-L112>@</a></blockquote><p>Adding nullchecks for current instruction will depend upon <code>unsafePointers[basePointer]</code>; if the <code>basePointer</code> i.e. <code>%a.addr</code> present in the <code>unsafePointers</code> then the value itself otherwise the <code>basePointer</code> is unsafe by default.<ol><li>Store instruction: When storing a value to a pointer it will make the pointer itself and all the child pointers unsafe. As we might have stored null into <code>%a.addr</code> thus making it unsafe when using it to load <code>%a</code>.<li>Load instruction: We’ll first add the value operand of the <code>basePointer</code> i.e. the loaded value to the <code>childPointers</code>. Then as the loaded pointer is always safe, we’ll write that fact into <code>unsafePointers</code>.<li>GetElementPtr instruction: Any pointer returned by this instruction will be checked for nullchecks when it is used. And the fact about it being null space will only be stored then.<li>Call (indirect) instruction: We’ll just make the function pointer safe and <code>basePointer</code> in this case is just the function pointer itself. Reasoning behind making the function pointer safe is explained later.<li>Alloca & Icmp instruction: For these instruction, we don’t need to do anything as we are not dereferencing any pointers.<li>Bitcast instruction: Same as alloca instruction we don’t need to do anything as we are just type casting the pointer not dereferencing it.<li>Branch instruction: This clears the <code>unsafePointers</code> map. <em>Reasoning explained above…</em><li>Ret instruction: This again does not do anything. <blockquote><p>Before returning we will always make the <code>basePointer</code> mark as safe. Reasoning is that if the current instructions executes after getting through the nullchecks, it means that the pointer is not null. And is safe to use for the coming instruction using that pointer.</blockquote></ol><h2 id=meet-operator>Meet operator</h2><p>This does not do anything as <code>childPointers</code> is preserved through out the function. And <code>unsafePointers</code> is empty at the start of each basic block, or in other words it also does not depend upon the incoming <code>unsafePointers</code> map from predecessor basic blocks.<h2 id=initialization>Initialization</h2><p>At the start of function <code>childPointers</code> is 0 initialized and <code>unsafePointers</code> is also 0 initialized at the start of each basic block.<h2 id=assumptions>Assumptions</h2><ol><li>Return type of any function is one of these <code>void</code>, <code>int</code>, <code>int *</code>. As the pass is adding default return values as the transmission instructions for the <code>NullBB</code> <em>(exhaustive declaration of return instructions).</em><li>Pointers passed in as function parameters are not taken in account of. Alternatively it is assumed that the function will not modify the pointers that are passed to it.<li>This pass is exhaustively tested on the given 8 test cases and may fail on anything outside the scope of those test cases.</ol><h2 id=miscellaneous>Miscellaneous</h2><ul><li>Outputs of all tests are compiled into <a href=https://github.com/hyouteki/problm/blob/main/nullchecks/nullchecks.out>nullchecks.out</a>.<li>All the instructions that requires nullchecks are the first instruction of every <code>NotNullBB</code>. LLVM IR files are present inside <a href=https://github.com/hyouteki/problm/tree/main/nullchecks/nullchecks_opt_ll>nullchecks_opt_ll</a>.</ul><h1 id=conservative-garbage-collecter-safe-gc-for-clang>Conservative garbage collecter (Safe GC) for Clang</h1><blockquote><p>SafeGC implements a bump allocator that always returns an 8-byte address.</blockquote><h2 id=building-the-project>Building the project</h2><pre class="language-bash z-code" data-lang=bash><code class=language-bash data-lang=bash><span class="z-source z-shell z-bash"><span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">git</span></span><span class="z-meta z-function-call z-arguments z-shell"> clone https://github.com/hyouteki/cop</span>
<span class="z-meta z-function-call z-shell"><span class="z-support z-function z-cd z-shell">cd</span></span><span class="z-meta z-function-call z-arguments z-shell"> safegc</span>
<span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">make</span></span>
</span></code></pre><h2 id=how-does-this-work-1>How does this work</h2><p>Safe GC has three components: allocator, mark and sweep.<h3 id=requirements>Requirements</h3><ul><li>Heap memory is always allocated via a safe memory management API (e.g., malloc).<li>If a heap object (say obj) is live, then the application must store its data in the range <code>[obj, obj + sizeof(obj)]</code> in its address space.</ul><h3 id=allocator>Allocator</h3><p>Safe GC implements a bump allocator and a stop-the-world conservative garbage collector. The allocator maintains a list of segments. All objects are allocated from a segment. A segment is a 4-GB contiguous memory area.<p><img alt="Layout of a Segment" src="https://github.com/hyouteki/cop/blob/main/safegc/images/segment_layout.jpg?raw=true"><figcaption>Layout of a segment</figcaption><p>Physical pages to the segment memory are allocated on demand. <code>ReservePtr</code> points to the end of the segment. <code>CommitPtr</code> points to a memory area until which the physical pages have been allocated. <code>AllocPtr</code> is the head of the bump allocator. The first 2-MB of the segment is reserved for metadata. The rest of the segment is used by the bump allocator. <code>DataPtr</code> points to the first byte in the data region of a segment.<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-source z-c"><span class="z-storage z-type z-c">typedef</span> <span class="z-storage z-type z-c">struct</span> ObjHeader <span class="z-meta z-block z-c"><span class="z-punctuation z-section z-block z-begin z-c">{</span>
    <span class="z-storage z-type z-c">unsigned</span> <span class="z-support z-type z-mac-classic z-c">Size</span><span class="z-punctuation z-terminator z-c">;</span>
    <span class="z-storage z-type z-c">unsigned</span> Status<span class="z-punctuation z-terminator z-c">;</span>
    ulong64 Type<span class="z-punctuation z-terminator z-c">;</span>
<span class="z-punctuation z-section z-block z-end z-c">}</span></span> <span class="z-entity z-name z-type z-typedef z-c">ObjHeader</span><span class="z-punctuation z-terminator z-c">;</span>
</span></code></pre><p>SafeGC adds an object header to each object. An object header contains the size, status, and type of the object. SafeGC doesn’t use the type field of the object header; reserved for future use. The status field contains the validity of an object. When an object is freed, the status filed of the object is set to <code>FREE</code>. The status field can also be used by the mark phase to <code>MARK</code> reachable objects. The bump allocator never reuses a virtual address. When a segment is full, a new segment is created for future allocations. <code>myfree</code> is called to free an object. myfree reclaims the physical page associated with a virtual page when all the objects on the virtual pages are freed. A virtual page is a 4-KB contiguous memory area in the segment address space. A virtual page is also aligned to 4-KB size. Future accesses to a freed virtual pages result in segmentation faults. SafeGC reserves two bytes metadata corresponding to each virtual page in the segment. The metadata is stored in a contiguous 2-MB memory area at the top of the segment. The virtual page metadata tracks the number of free bytes on a virtual page. When the number of free bytes becomes equal to the size of a virtual page, the corresponding physical page is reclaimed. When the allocation size of an object is less than 4-KB (page size), SafeGC ensures that the object always lies on a single page. The top of a virtual page always contains the starting address (address of object header) of an object. Allocations of size more than 4-KB allocations are called big allocations. SafeGC implements a different allocation scheme for big allocations. For big allocations, the allocation size is adjusted to the nearest multiple of the page size. For these allocations, myfree immediately reclaims the physical pages. The metadata corresponding to the first page of a big allocation is set to one to identify the first byte of these objects. myfree sets the metadata corresponding to all pages of a big allocation to the page size. The metadata can be used by the mark and sweep phase to check the validity of a page before access, and also for the finding the object headers of big allocations.<h3 id=mark>Mark</h3><p><strong>Scanning roots</strong>: It scans the heap and stack for the 8-bytes aligned valid heap address. After encountering a valid heap address it finds the object header corresponding to that address and <code>MARK</code> it if not adready marked and add it to the unscanned objects list.<p>After scanning of the roots is complete. It iterates over each heap object in the unscanned objects list and check for references to valid heap addresses in that object. After encountering a valid heap address it proceeds to do the same as mentioned in the scan roots phase.<h3 id=sweep>Sweep</h3><p>It iterates over all the valid heap addresses and fetch their corresponding object header if an object not marked and not freed is found it proceeds to free them using <code>myfree</code> routine.<blockquote><p><strong>Warning</strong>: Due to viewing all the value which have holds a valid heap address as a pointer to the heap memory; a conservative garbage collector may incorrectly identify unreachable objects (whose addresses matches with an integer) as reachable, which could lead to a memory leak. Fortunately, in most applications, such cases are few, and thus it is practical to implement conservative garbage collection for them.</blockquote><h2 id=tests>Tests</h2><p>Run tests using <code>make test</code><pre class="language-bash z-code" data-lang=bash><code class=language-bash data-lang=bash><span class="z-source z-shell z-bash"><span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">/usr/bin/time</span></span><span class="z-meta z-function-call z-arguments z-shell"><span class="z-variable z-parameter z-option z-shell"><span class="z-punctuation z-definition z-parameter z-shell"> -</span>v</span> ./random</span>
<span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">total</span></span><span class="z-meta z-function-call z-arguments z-shell"> edges:4222800</span>
<span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">Num</span></span><span class="z-meta z-function-call z-arguments z-shell"> Bytes Allocated: 476002816</span>
<span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">Num</span></span><span class="z-meta z-function-call z-arguments z-shell"> Bytes Freed: 52107408</span>
<span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">Num</span></span><span class="z-meta z-function-call z-arguments z-shell"> GC Triggered: 14</span>
<span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">printing</span></span><span class="z-meta z-function-call z-arguments z-shell"> stats after final GC</span>
<span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">Num</span></span><span class="z-meta z-function-call z-arguments z-shell"> Bytes Allocated: 476002816</span>
<span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">Num</span></span><span class="z-meta z-function-call z-arguments z-shell"> Bytes Freed: 53603152</span>
<span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">Num</span></span><span class="z-meta z-function-call z-arguments z-shell"> GC Triggered: 15</span>
    <span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">Command</span></span><span class="z-meta z-function-call z-arguments z-shell"> being timed: <span class="z-string z-quoted z-double z-shell"><span class="z-punctuation z-definition z-string z-begin z-shell">"</span>./random<span class="z-punctuation z-definition z-string z-end z-shell">"</span></span></span>
    <span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">User</span></span><span class="z-meta z-function-call z-arguments z-shell"> time (seconds</span><span class="z-meta z-function-call z-shell"></span>)<span class="z-meta z-function-call z-shell"><span class="z-support z-function z-colon z-shell">:</span></span><span class="z-meta z-function-call z-arguments z-shell"> 8.36</span>
    <span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">System</span></span><span class="z-meta z-function-call z-arguments z-shell"> time (seconds</span><span class="z-meta z-function-call z-shell"></span>)<span class="z-meta z-function-call z-shell"><span class="z-support z-function z-colon z-shell">:</span></span><span class="z-meta z-function-call z-arguments z-shell"> 0.32</span>
    <span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">Percent</span></span><span class="z-meta z-function-call z-arguments z-shell"> of CPU this job got: 99<span class="z-meta z-group z-expansion z-job z-shell"><span class="z-punctuation z-definition z-variable z-job z-shell">%</span></span></span>
    <span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">Elapsed</span></span><span class="z-meta z-function-call z-arguments z-shell"> (wall clock</span><span class="z-meta z-function-call z-shell"></span>) <span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">time</span></span><span class="z-meta z-function-call z-arguments z-shell"> (h:mm:ss or m:ss</span><span class="z-meta z-function-call z-shell"></span>)<span class="z-meta z-function-call z-shell"><span class="z-support z-function z-colon z-shell">:</span></span><span class="z-meta z-function-call z-arguments z-shell"> 0:08.70</span>
    <span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">Average</span></span><span class="z-meta z-function-call z-arguments z-shell"> shared text size (kbytes</span><span class="z-meta z-function-call z-shell"></span>)<span class="z-meta z-function-call z-shell"><span class="z-support z-function z-colon z-shell">:</span></span><span class="z-meta z-function-call z-arguments z-shell"> 0</span>
    <span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">Average</span></span><span class="z-meta z-function-call z-arguments z-shell"> unshared data size (kbytes</span><span class="z-meta z-function-call z-shell"></span>)<span class="z-meta z-function-call z-shell"><span class="z-support z-function z-colon z-shell">:</span></span><span class="z-meta z-function-call z-arguments z-shell"> 0</span>
    <span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">Average</span></span><span class="z-meta z-function-call z-arguments z-shell"> stack size (kbytes</span><span class="z-meta z-function-call z-shell"></span>)<span class="z-meta z-function-call z-shell"><span class="z-support z-function z-colon z-shell">:</span></span><span class="z-meta z-function-call z-arguments z-shell"> 0</span>
    <span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">Average</span></span><span class="z-meta z-function-call z-arguments z-shell"> total size (kbytes</span><span class="z-meta z-function-call z-shell"></span>)<span class="z-meta z-function-call z-shell"><span class="z-support z-function z-colon z-shell">:</span></span><span class="z-meta z-function-call z-arguments z-shell"> 0</span>
    <span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">Maximum</span></span><span class="z-meta z-function-call z-arguments z-shell"> resident set size (kbytes</span><span class="z-meta z-function-call z-shell"></span>)<span class="z-meta z-function-call z-shell"><span class="z-support z-function z-colon z-shell">:</span></span><span class="z-meta z-function-call z-arguments z-shell"> 519588</span>
    <span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">Average</span></span><span class="z-meta z-function-call z-arguments z-shell"> resident set size (kbytes</span><span class="z-meta z-function-call z-shell"></span>)<span class="z-meta z-function-call z-shell"><span class="z-support z-function z-colon z-shell">:</span></span><span class="z-meta z-function-call z-arguments z-shell"> 0</span>
    <span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">Major</span></span><span class="z-meta z-function-call z-arguments z-shell"> (requiring I/O</span><span class="z-meta z-function-call z-shell"></span>) <span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">page</span></span><span class="z-meta z-function-call z-arguments z-shell"> faults: 2</span>
    <span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">Minor</span></span><span class="z-meta z-function-call z-arguments z-shell"> (reclaiming a frame</span><span class="z-meta z-function-call z-shell"></span>) <span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">page</span></span><span class="z-meta z-function-call z-arguments z-shell"> faults: 128639</span>
    <span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">Voluntary</span></span><span class="z-meta z-function-call z-arguments z-shell"> context switches: 73</span>
    <span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">Involuntary</span></span><span class="z-meta z-function-call z-arguments z-shell"> context switches: 10</span>
    <span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">Swaps:</span></span><span class="z-meta z-function-call z-arguments z-shell"> 0</span>
    <span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">File</span></span><span class="z-meta z-function-call z-arguments z-shell"> system inputs: 88</span>
    <span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">File</span></span><span class="z-meta z-function-call z-arguments z-shell"> system outputs: 0</span>
    <span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">Socket</span></span><span class="z-meta z-function-call z-arguments z-shell"> messages sent: 0</span>
    <span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">Socket</span></span><span class="z-meta z-function-call z-arguments z-shell"> messages received: 0</span>
    <span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">Signals</span></span><span class="z-meta z-function-call z-arguments z-shell"> delivered: 0</span>
    <span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">Page</span></span><span class="z-meta z-function-call z-arguments z-shell"> size (bytes</span><span class="z-meta z-function-call z-shell"></span>)<span class="z-meta z-function-call z-shell"><span class="z-support z-function z-colon z-shell">:</span></span><span class="z-meta z-function-call z-arguments z-shell"> 4096</span>
    <span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">Exit</span></span><span class="z-meta z-function-call z-arguments z-shell"> status: 0</span>
</span></code></pre><h1 id=spatial-and-weaker-type-safety-for-the-c-lang>Spatial and weaker type safety for the C lang</h1><blockquote><p>This pass aims to enforce spatial and a weaker type safety for the C language via disallowing out-of-bound pointer accesses and having pointers with invalid addresses.</blockquote><h2 id=building-the-pass-from-scratch-1>Building the pass from scratch</h2><pre class="language-bash z-code" data-lang=bash><code class=language-bash data-lang=bash><span class="z-source z-shell z-bash"><span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">git</span></span><span class="z-meta z-function-call z-arguments z-shell"> clone https://github.com/Systems-IIITD/CSE601</span>
<span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">git</span></span><span class="z-meta z-function-call z-arguments z-shell"> clone https://github.com/hyouteki/cop</span>
<span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">mv</span></span><span class="z-meta z-function-call z-arguments z-shell"> cop/nullchecks/NullChecks.cpp CSE601/llvm/lib/CodeGen/SafeC/</span>
<span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">sudo</span></span><span class="z-meta z-function-call z-arguments z-shell"> apt install cmake ninja-build</span>
</span></code></pre><pre class="language-bash z-code" data-lang=bash><code class=language-bash data-lang=bash><span class="z-source z-shell z-bash"><span class="z-meta z-function-call z-shell"><span class="z-support z-function z-cd z-shell">cd</span></span><span class="z-meta z-function-call z-arguments z-shell"> CSE601</span>
<span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">mkdir</span></span><span class="z-meta z-function-call z-arguments z-shell"> build</span>
<span class="z-meta z-function-call z-shell"><span class="z-support z-function z-cd z-shell">cd</span></span><span class="z-meta z-function-call z-arguments z-shell"> build</span> <span class="z-keyword z-operator z-logical z-and z-shell">&&</span> <span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">cp</span></span><span class="z-meta z-function-call z-arguments z-shell"> ../scripts/build.sh .</span> <span class="z-keyword z-operator z-logical z-and z-shell">&&</span> <span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">sh</span></span><span class="z-meta z-function-call z-arguments z-shell"> build.sh</span> <span class="z-keyword z-operator z-logical z-and z-shell">&&</span> <span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">ninja</span></span><span class="z-meta z-function-call z-arguments z-shell"><span class="z-variable z-parameter z-option z-shell"><span class="z-punctuation z-definition z-parameter z-shell"> -</span>j</span> 4</span>
<span class="z-meta z-function-call z-shell"><span class="z-support z-function z-cd z-shell">cd</span></span><span class="z-meta z-function-call z-arguments z-shell"> tests</span> <span class="z-keyword z-operator z-logical z-and z-shell">&&</span> <span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">make</span></span>
</span></code></pre><blockquote><p><strong>Note</strong>: If you encounter error such as<pre class="language-bash z-code" data-lang=bash><code class=language-bash data-lang=bash><span class="z-source z-shell z-bash"><span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">/home/puneetku/CSE601/llvm/utils/benchmark/src/benchmark_register.h:17:30:</span></span><span class="z-meta z-function-call z-arguments z-shell"> error: ‘numeric_limits’ is not a member of ‘std’</span>
<span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">17</span></span> <span class="z-keyword z-operator z-logical z-pipe z-shell">|</span>   <span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">static</span></span><span class="z-meta z-function-call z-arguments z-shell"> const T kmax = std::numeric_limits<span class="z-keyword z-operator z-assignment z-redirection z-shell"><</span>T<span class="z-keyword z-operator z-assignment z-redirection z-shell">></span>::max(</span><span class="z-meta z-function-call z-shell"></span>)<span class="z-keyword z-operator z-logical z-continue z-shell">;</span>
</span></code></pre><p>Try adding <code>#include&LTlimits></code> in the header file and re-building the project</blockquote><blockquote><p><strong>Note</strong>: For subsequent builds just run <code>cd build && ninja -j 4</code> inside <code>CSE601</code> directory</blockquote><blockquote><p><strong>Note</strong>: For testing the pass run the following command <code>cd tests/PA1/ && make clean && make -B</code> inside <code>CSE601</code> directory</blockquote><h2 id=how-does-this-work-2>How does this work</h2><p>C allows pointer typecasting to non-pointer types and pointer arithmetic. Thus, directly enforcing type checks at runtime is not feasible. To address this, we utilize the <code>mymalloc</code> routine, which tracks objects’ size and type information, enabling dynamic enforcement of memory safety by storing object metadata just before the object itself.<p>More than just keeping track of the base pointer is required; as in C, a pointer can be typecasted to unsigned long long and passed to a function. Thus, we must keep track of all the variations (child pointers) of the base pointer (parent pointer).<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-source z-c"><span class="z-storage z-type z-c">int</span> <span class="z-keyword z-operator z-c">*</span>ptr <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span><span class="z-storage z-type z-c">int</span> <span class="z-keyword z-operator z-c">*</span><span class="z-punctuation z-section z-group z-end z-c">)</span></span><span class="z-meta z-function-call z-c"><span class="z-variable z-function z-c">mymalloc</span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span></span></span><span class="z-meta z-function-call z-c"><span class="z-meta z-group z-c"><span class="z-keyword z-operator z-word z-c">sizeof</span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span></span><span class="z-meta z-group z-c"><span class="z-storage z-type z-c">int</span></span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-end z-c">)</span></span><span class="z-keyword z-operator z-c">*</span><span class="z-constant z-numeric z-integer z-decimal z-c">1</span></span></span><span class="z-meta z-function-call z-c"><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-end z-c">)</span></span></span><span class="z-punctuation z-terminator z-c">;</span>
<span class="z-storage z-type z-c">unsigned</span> <span class="z-storage z-type z-c">long</span> <span class="z-storage z-type z-c">long</span> a <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span><span class="z-storage z-type z-c">unsigned</span> <span class="z-storage z-type z-c">long</span> <span class="z-storage z-type z-c">long</span><span class="z-punctuation z-section z-group z-end z-c">)</span></span>ptr<span class="z-punctuation z-terminator z-c">;</span>
</span></code></pre><pre class="language-llvm z-code" data-lang=llvm><code class=language-llvm data-lang=llvm><span class="z-text z-plain">%ptr_addr = alloca i32*, align 8
%a = alloca i64, align 8	
%mymalloc_call = call noalias i8* @mymalloc(i64 4) #2
%mymalloc_output = bitcast i8* %mymalloc_call to i32*
store i32* %0, i32** %ptr_addr, align 8
%1 = load i32*, i32** %ptr_addr, align 8
%2 = ptrtoint i32* %1 to i64
store i64 %2, i64* %a, align 8
</span></code></pre><blockquote><p>As <code>a</code> is not a pointer but dynamically contains a pointer value. Thus we need to keep track of it as well. For this we need to track the pointer going through different instructions such as bitCastInst, getElementPtrInst, etc. In this example <code>a</code> is a child pointer of the parent pointer <code>ptr</code>.</blockquote><p>The first step is to replace every alloca instruction (stack allocation) and malloc call instruction (heap allocation) with a mymalloc call instruction (heap allocation of object and object metadata) so that we have access to the object metadata. For the alloca instruction, we need to determine the size of the requested object, which is done using the custom <a href=https://github.com/hyouteki/cop/blob/85915ab3f302626b6d80e7687dd354431654bb06/memsafe/MemSafe.cpp#L67-L80C2>getSizeOfAlloca</a> routine. Once the size of the alloca instruction is calculated, we insert a mymalloc API call and include the myfree (equivalent to the free routine) after the last use of the alloca instruction found in the original LLVM IR.<blockquote><p>This is handled by the <a href=https://github.com/hyouteki/cop/blob/8c91b14a81bb1a3a23e77d700422e2ac2c6161ab/memsafe/MemSafe.cpp#L82-L191>replaceAllocaToMymalloc</a> API.</blockquote><p>Next step is to disallow out-of-bounds pointer accesses which is handled by the <a href=https://github.com/hyouteki/cop/blob/8c91b14a81bb1a3a23e77d700422e2ac2c6161ab/memsafe/MemSafe.cpp#L193-L259C2>disallowOutOfBoundsPtr</a> API. It works by finding all the pointer accesses and adds a call instruction to a custom <a href=https://github.com/hyouteki/cop/blob/25c99cc5e4b7b7f1dde801def996db181f25a3f1/memsafe/support.c#L96-L115C2>isSafeToEscapeFunc</a> before the current pointer access. The <code>isSafeToEscapeFunc</code> routine works by finding the closest base pointer of the given pointer and checks whether the given pointer lies in the bounds, i.e. <code>[basePointer, basePointer+baseSize)</code> of the base pointer.<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-source z-c"><span class="z-storage z-type z-c">int</span> <span class="z-keyword z-operator z-c">*</span>arr <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span><span class="z-storage z-type z-c">int</span> <span class="z-keyword z-operator z-c">*</span><span class="z-punctuation z-section z-group z-end z-c">)</span></span><span class="z-meta z-function-call z-c"><span class="z-variable z-function z-c">mymalloc</span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span></span></span><span class="z-meta z-function-call z-c"><span class="z-meta z-group z-c"><span class="z-keyword z-operator z-word z-c">sizeof</span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span></span><span class="z-meta z-group z-c"><span class="z-storage z-type z-c">int</span></span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-end z-c">)</span></span><span class="z-keyword z-operator z-c">*</span><span class="z-constant z-numeric z-integer z-decimal z-c">50</span></span></span><span class="z-meta z-function-call z-c"><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-end z-c">)</span></span></span><span class="z-punctuation z-terminator z-c">;</span>
arr<span class="z-meta z-brackets z-c"><span class="z-punctuation z-section z-brackets z-begin z-c">[</span><span class="z-constant z-numeric z-integer z-decimal z-c">0</span><span class="z-punctuation z-section z-brackets z-end z-c">]</span></span> <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-constant z-numeric z-integer z-decimal z-c">1</span><span class="z-punctuation z-terminator z-c">;</span>
arr<span class="z-meta z-brackets z-c"><span class="z-punctuation z-section z-brackets z-begin z-c">[</span><span class="z-constant z-numeric z-integer z-decimal z-c">51</span><span class="z-punctuation z-section z-brackets z-end z-c">]</span></span> <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-constant z-numeric z-integer z-decimal z-c">1</span><span class="z-punctuation z-terminator z-c">;</span>   <span class="z-comment z-line z-double-slash z-c"><span class="z-punctuation z-definition z-comment z-c">//</span> OOB access
</span><span class="z-keyword z-operator z-c">*</span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span>arr<span class="z-keyword z-operator z-arithmetic z-c">+</span><span class="z-constant z-numeric z-integer z-decimal z-c">52</span><span class="z-punctuation z-section z-group z-end z-c">)</span></span> <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-constant z-numeric z-integer z-decimal z-c">1</span><span class="z-punctuation z-terminator z-c">;</span> <span class="z-comment z-line z-double-slash z-c"><span class="z-punctuation z-definition z-comment z-c">//</span> OOB access
</span><span class="z-meta z-function-call z-c"><span class="z-variable z-function z-c">foo</span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span></span></span><span class="z-meta z-function-call z-c"><span class="z-meta z-group z-c"><span class="z-keyword z-operator z-c">&</span>arr<span class="z-keyword z-operator z-arithmetic z-c">+</span><span class="z-constant z-numeric z-integer z-decimal z-c">53</span></span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-end z-c">)</span></span></span><span class="z-punctuation z-terminator z-c">;</span>  <span class="z-comment z-line z-double-slash z-c"><span class="z-punctuation z-definition z-comment z-c">//</span> OOB access
</span></span></code></pre><blockquote><p>Demonstrations of Out-of-bounds pointer accesses.</blockquote><pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-source z-c"><span class="z-storage z-type z-c">int</span> <span class="z-keyword z-operator z-c">*</span>arr <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span><span class="z-storage z-type z-c">int</span> <span class="z-keyword z-operator z-c">*</span><span class="z-punctuation z-section z-group z-end z-c">)</span></span><span class="z-meta z-function-call z-c"><span class="z-variable z-function z-c">mymalloc</span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span></span></span><span class="z-meta z-function-call z-c"><span class="z-meta z-group z-c"><span class="z-keyword z-operator z-word z-c">sizeof</span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span></span><span class="z-meta z-group z-c"><span class="z-storage z-type z-c">int</span></span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-end z-c">)</span></span><span class="z-keyword z-operator z-c">*</span><span class="z-constant z-numeric z-integer z-decimal z-c">50</span></span></span><span class="z-meta z-function-call z-c"><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-end z-c">)</span></span></span><span class="z-punctuation z-terminator z-c">;</span>
<span class="z-meta z-function-call z-c"><span class="z-variable z-function z-c">isSafeToEscapeFunc</span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span></span></span><span class="z-meta z-function-call z-c"><span class="z-meta z-group z-c">arr</span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-end z-c">)</span></span></span><span class="z-punctuation z-terminator z-c">;</span>    <span class="z-comment z-line z-double-slash z-c"><span class="z-punctuation z-definition z-comment z-c">//</span> Pass
</span>arr<span class="z-meta z-brackets z-c"><span class="z-punctuation z-section z-brackets z-begin z-c">[</span><span class="z-constant z-numeric z-integer z-decimal z-c">0</span><span class="z-punctuation z-section z-brackets z-end z-c">]</span></span> <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-constant z-numeric z-integer z-decimal z-c">1</span><span class="z-punctuation z-terminator z-c">;</span>
<span class="z-meta z-function-call z-c"><span class="z-variable z-function z-c">isSafeToEscapeFunc</span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span></span></span><span class="z-meta z-function-call z-c"><span class="z-meta z-group z-c">arr<span class="z-keyword z-operator z-arithmetic z-c">+</span><span class="z-constant z-numeric z-integer z-decimal z-c">51</span></span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-end z-c">)</span></span></span><span class="z-punctuation z-terminator z-c">;</span> <span class="z-comment z-line z-double-slash z-c"><span class="z-punctuation z-definition z-comment z-c">//</span> `Error: invalid pointer\nIssue: pointer out of bounds of base pointer\n`
</span>arr<span class="z-meta z-brackets z-c"><span class="z-punctuation z-section z-brackets z-begin z-c">[</span><span class="z-constant z-numeric z-integer z-decimal z-c">51</span><span class="z-punctuation z-section z-brackets z-end z-c">]</span></span> <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-constant z-numeric z-integer z-decimal z-c">1</span><span class="z-punctuation z-terminator z-c">;</span>
<span class="z-meta z-function-call z-c"><span class="z-variable z-function z-c">isSafeToEscapeFunc</span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span></span></span><span class="z-meta z-function-call z-c"><span class="z-meta z-group z-c">arr<span class="z-keyword z-operator z-arithmetic z-c">+</span><span class="z-constant z-numeric z-integer z-decimal z-c">52</span></span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-end z-c">)</span></span></span><span class="z-punctuation z-terminator z-c">;</span> <span class="z-comment z-line z-double-slash z-c"><span class="z-punctuation z-definition z-comment z-c">//</span> `Error: invalid pointer\nIssue: pointer out of bounds of base pointer\n`
</span><span class="z-keyword z-operator z-c">*</span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span>arr<span class="z-keyword z-operator z-arithmetic z-c">+</span><span class="z-constant z-numeric z-integer z-decimal z-c">52</span><span class="z-punctuation z-section z-group z-end z-c">)</span></span> <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-constant z-numeric z-integer z-decimal z-c">1</span><span class="z-punctuation z-terminator z-c">;</span>
<span class="z-meta z-function-call z-c"><span class="z-variable z-function z-c">isSafeToEscapeFunc</span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span></span></span><span class="z-meta z-function-call z-c"><span class="z-meta z-group z-c">arr<span class="z-keyword z-operator z-arithmetic z-c">+</span><span class="z-constant z-numeric z-integer z-decimal z-c">53</span></span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-end z-c">)</span></span></span><span class="z-punctuation z-terminator z-c">;</span> <span class="z-comment z-line z-double-slash z-c"><span class="z-punctuation z-definition z-comment z-c">//</span> `Error: invalid pointer\nIssue: pointer out of bounds of base pointer\n`
</span><span class="z-meta z-function-call z-c"><span class="z-variable z-function z-c">foo</span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span></span></span><span class="z-meta z-function-call z-c"><span class="z-meta z-group z-c">arr<span class="z-keyword z-operator z-arithmetic z-c">+</span><span class="z-constant z-numeric z-integer z-decimal z-c">53</span></span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-end z-c">)</span></span></span><span class="z-punctuation z-terminator z-c">;</span>
</span></code></pre><blockquote><p>C equivalent of the updated LLVM IR after passing through the <code>disallowOutOfBoundsPtr</code> API.</blockquote><p>Lastly, we add write barriers via <a href=https://github.com/hyouteki/cop/blob/8c91b14a81bb1a3a23e77d700422e2ac2c6161ab/memsafe/MemSafe.cpp#L261-L286C2>addWriteBarriers</a> API to identify instances where invalid heap addresses are getting stored into pointers. This API works by getting the pointer operand from all the store instructions and passing it to a custom <a href=https://github.com/hyouteki/cop/blob/25c99cc5e4b7b7f1dde801def996db181f25a3f1/memsafe/support.c#L117-L141C2>checkWriteBarrier</a> routine which validates the heap address. This API also works if we store to an object which contains a pointer operand.<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-source z-c"><span class="z-storage z-type z-c">int</span> <span class="z-keyword z-operator z-c">*</span>ptr <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span><span class="z-storage z-type z-c">int</span> <span class="z-keyword z-operator z-c">*</span><span class="z-punctuation z-section z-group z-end z-c">)</span></span><span class="z-meta z-function-call z-c"><span class="z-variable z-function z-c">mymalloc</span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span></span></span><span class="z-meta z-function-call z-c"><span class="z-meta z-group z-c"><span class="z-keyword z-operator z-word z-c">sizeof</span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span></span><span class="z-meta z-group z-c"><span class="z-storage z-type z-c">int</span></span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-end z-c">)</span></span><span class="z-keyword z-operator z-c">*</span><span class="z-constant z-numeric z-integer z-decimal z-c">50</span></span></span><span class="z-meta z-function-call z-c"><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-end z-c">)</span></span></span><span class="z-punctuation z-terminator z-c">;</span>                  <span class="z-comment z-line z-double-slash z-c"><span class="z-punctuation z-definition z-comment z-c">//</span> valid address
</span><span class="z-storage z-type z-c">int</span> <span class="z-keyword z-operator z-c">*</span>a <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span><span class="z-storage z-type z-c">int</span> <span class="z-keyword z-operator z-c">*</span><span class="z-punctuation z-section z-group z-end z-c">)</span></span><span class="z-constant z-numeric z-integer z-decimal z-c">0</span><span class="z-punctuation z-terminator z-c">;</span>                                           <span class="z-comment z-line z-double-slash z-c"><span class="z-punctuation z-definition z-comment z-c">//</span> invalid address
</span>LinkedListNode node <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-meta z-block z-c"><span class="z-punctuation z-section z-block z-begin z-c">{</span><span class="z-punctuation z-accessor z-c">.</span><span class="z-variable z-other z-member z-c">Value</span><span class="z-keyword z-operator z-assignment z-c">=</span><span class="z-constant z-numeric z-integer z-decimal z-c">1</span><span class="z-punctuation z-separator z-c">,</span> <span class="z-punctuation z-accessor z-c">.</span><span class="z-variable z-other z-member z-c">Next</span><span class="z-keyword z-operator z-assignment z-c">=</span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span>LinkedListNode <span class="z-keyword z-operator z-c">*</span><span class="z-punctuation z-section z-group z-end z-c">)</span></span><span class="z-constant z-numeric z-integer z-decimal z-c">0</span><span class="z-punctuation z-section z-block z-end z-c">}</span></span><span class="z-punctuation z-terminator z-c">;</span> <span class="z-comment z-line z-double-slash z-c"><span class="z-punctuation z-definition z-comment z-c">//</span> invalid address
</span></span></code></pre><blockquote><p>Demonstration of invalid address. The address 0 is getting stored in the variable <code>a</code>, which is invalid. The same is true for the variable <code>node</code>, where address 0 is getting stored in the <code>Next</code> field, which is invalid.</blockquote><pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-source z-c"><span class="z-storage z-type z-c">int</span> <span class="z-keyword z-operator z-c">*</span>ptr <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span><span class="z-storage z-type z-c">int</span> <span class="z-keyword z-operator z-c">*</span><span class="z-punctuation z-section z-group z-end z-c">)</span></span><span class="z-meta z-function-call z-c"><span class="z-variable z-function z-c">mymalloc</span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span></span></span><span class="z-meta z-function-call z-c"><span class="z-meta z-group z-c"><span class="z-keyword z-operator z-word z-c">sizeof</span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span></span><span class="z-meta z-group z-c"><span class="z-storage z-type z-c">int</span></span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-end z-c">)</span></span><span class="z-keyword z-operator z-c">*</span><span class="z-constant z-numeric z-integer z-decimal z-c">50</span></span></span><span class="z-meta z-function-call z-c"><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-end z-c">)</span></span></span><span class="z-punctuation z-terminator z-c">;</span>
<span class="z-meta z-function-call z-c"><span class="z-variable z-function z-c">checkWriteBarrier</span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span></span></span><span class="z-meta z-function-call z-c"><span class="z-meta z-group z-c">ptr</span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-end z-c">)</span></span></span><span class="z-punctuation z-terminator z-c">;</span> <span class="z-comment z-line z-double-slash z-c"><span class="z-punctuation z-definition z-comment z-c">//</span> Pass
</span><span class="z-meta z-function-call z-c"><span class="z-variable z-function z-c">checkWriteBarrier</span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span></span></span><span class="z-meta z-function-call z-c"><span class="z-meta z-group z-c"><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span><span class="z-storage z-type z-c">int</span> <span class="z-keyword z-operator z-c">*</span><span class="z-punctuation z-section z-group z-end z-c">)</span></span><span class="z-constant z-numeric z-integer z-decimal z-c">0</span></span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-end z-c">)</span></span></span><span class="z-punctuation z-terminator z-c">;</span>
<span class="z-storage z-type z-c">int</span> <span class="z-keyword z-operator z-c">*</span>a <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span><span class="z-storage z-type z-c">int</span> <span class="z-keyword z-operator z-c">*</span><span class="z-punctuation z-section z-group z-end z-c">)</span></span><span class="z-constant z-numeric z-integer z-decimal z-c">0</span><span class="z-punctuation z-terminator z-c">;</span>      <span class="z-comment z-line z-double-slash z-c"><span class="z-punctuation z-definition z-comment z-c">//</span> `Error: invalid pointer (int *)0 found inside (int *)0\n`
</span><span class="z-meta z-function-call z-c"><span class="z-variable z-function z-c">checkWriteBarrier</span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span></span></span><span class="z-meta z-function-call z-c"><span class="z-meta z-group z-c"><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span>LinkedListNode<span class="z-punctuation z-section z-group z-end z-c">)</span></span><span class="z-meta z-block z-c"><span class="z-punctuation z-section z-block z-begin z-c">{</span><span class="z-punctuation z-accessor z-c">.</span><span class="z-variable z-other z-member z-c">Value</span><span class="z-keyword z-operator z-assignment z-c">=</span><span class="z-constant z-numeric z-integer z-decimal z-c">1</span><span class="z-punctuation z-separator z-c">,</span> <span class="z-punctuation z-accessor z-c">.</span><span class="z-variable z-other z-member z-c">Next</span><span class="z-keyword z-operator z-assignment z-c">=</span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span>LinkedListNode <span class="z-keyword z-operator z-c">*</span><span class="z-punctuation z-section z-group z-end z-c">)</span></span><span class="z-constant z-numeric z-integer z-decimal z-c">0</span><span class="z-punctuation z-section z-block z-end z-c">}</span></span></span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-end z-c">)</span></span></span><span class="z-punctuation z-terminator z-c">;</span>
<span class="z-comment z-line z-double-slash z-c"><span class="z-punctuation z-definition z-comment z-c">//</span> `Error: invalid pointer (LinkedListNode *)0 found inside (LinkedListNode){.Value=1, .Next=(LinkedListNode *)0}\n`
</span>LinkedListNode node <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-meta z-block z-c"><span class="z-punctuation z-section z-block z-begin z-c">{</span><span class="z-punctuation z-accessor z-c">.</span><span class="z-variable z-other z-member z-c">Value</span><span class="z-keyword z-operator z-assignment z-c">=</span><span class="z-constant z-numeric z-integer z-decimal z-c">1</span><span class="z-punctuation z-separator z-c">,</span> <span class="z-punctuation z-accessor z-c">.</span><span class="z-variable z-other z-member z-c">Next</span><span class="z-keyword z-operator z-assignment z-c">=</span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span>LinkedListNode <span class="z-keyword z-operator z-c">*</span><span class="z-punctuation z-section z-group z-end z-c">)</span></span><span class="z-constant z-numeric z-integer z-decimal z-c">0</span><span class="z-punctuation z-section z-block z-end z-c">}</span></span><span class="z-punctuation z-terminator z-c">;</span>
</span></code></pre><blockquote><p>C equivalent of the updated LLVM IR after passing through the <code>addWriteBarriers</code> API.</blockquote><h2 id=miscellaneous-1>Miscellaneous</h2><blockquote><p><strong>Note</strong>: We can also use a custom null pointer dereference detection compiler pass in conjunction with this pass for added type safety for C lang. Which can be found <a href=https://hyouteki.github.io/projects/cop/#null-pointer-dereference-detection-compiler-pass>here</a>.</blockquote><br><a class=inline-button href=https://github.com/hyouteki/cop style=margin:10px>Repository</a><a class=inline-button href=https://github.com/hyouteki/cop/blob/main/LICENSE style=margin:10px>License GPL-3.0</a><hr><nav class=post-nav><a class="post-nav-item post-nav-prev" href=https://hyouteki.github.io/projects/wikiracing/> <div class=nav-arrow>← Previous</div> <span class=post-title>Wikiracing - Chromium Extension</span> </a><a class="post-nav-item post-nav-next" href=https://hyouteki.github.io/projects/senet/> <div class=nav-arrow>Next →</div> <span class=post-title>probing SEcurity de NETwork</span> </a></nav><p class=dialog-buttons><a class=inline-button href=#top>Go to top</a> <a class="inline-button colored" href=https://github.com/hyouteki/hyouteki.github.io/issues>File an issue</a></div><footer class=footer><p title="Last built at 2025-02-10 16:16 +00:00"><small>© Ninthcircle, 2025</small><p><small>Powered by <a href=https://www.getzola.org>Zola</a> and <a href=https://daudix.codeberg.page/duckquill>Duckquill</a></small></footer>